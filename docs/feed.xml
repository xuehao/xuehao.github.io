<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh"><generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator><link href="http://localhost:8000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:8000/" rel="alternate" type="text/html" hreflang="zh" /><updated>2024-01-24T17:15:05+08:00</updated><id>http://localhost:8000/feed.xml</id><title type="html">薛浩的博客</title><subtitle>专注工业软件领域，分享数理、编程、模拟、可视化等内容。更多精彩，敬请关注：[stickmind.com](https://www.stickmind.com){:target=&quot;_blank&quot;}！
</subtitle><author><name>薛浩</name><email>xuehao0618@outlook.com</email></author><entry><title type="html">编写兼容 STL 的 HashMap 容器</title><link href="http://localhost:8000/cs2/2023/06/13/let-us-write-a-hashmap.html" rel="alternate" type="text/html" title="编写兼容 STL 的 HashMap 容器" /><published>2023-06-13T00:00:00+08:00</published><updated>2023-06-13T00:00:00+08:00</updated><id>http://localhost:8000/cs2/2023/06/13/let-us-write-a-hashmap</id><content type="html" xml:base="http://localhost:8000/cs2/2023/06/13/let-us-write-a-hashmap.html"><![CDATA[<p>本文改编自斯坦福 CS106L 的一份作业，详细的背景介绍可以参考<a href="https://web.stanford.edu/class/cs106l/assignment2.html" target="_blank">官方文档</a>。</p>

<p>改版后的初始项目代码<strong>不包含迭代器的内容</strong>，所以在实现的过程中注意不要使用基于范围的 <code class="language-plaintext highlighter-rouge">for</code> 循环进行迭代。虽然使用传统的 <code class="language-plaintext highlighter-rouge">for</code> 循环处理略微繁琐，但不失为一个练习的契机。</p>

<p>在完成本项目的练习后，你将有两个选择。其一，继续参考公开的教材和资料，独立完成迭代器的开发工作；其二，斯坦福的初始项目已经包含了完整的迭代器代码实现，可以直接借用，改写本项目代码，体会迭代器开发的过程。</p>

<p><em>本小节视频讲解时间段 <a href="https://h8pqt7tpdf.feishu.cn/file/Kh7obHaxNoxsGWxfziqcUfFTn3d" target="_blank">01:04:22-01:15:30</a></em></p>

<h2 id="milestone-0阅读">Milestone 0：阅读</h2>

<p><a href="/assets/files/2023/HashMap-starter.zip">初始项目</a>包含如下文件：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HashMap/
	include/
		hashmap.h 包含 HashMap 的定义，在这里添加你的定义
		hashmap_impl.h 包含 HashMap 的实现，在这里添加你的实现
		hashmap_iterator.h 用于后续添加迭代器的代码
		test_settings.h 用于开关每个子任务的默认测试案例
		rang.h 用于终端文本颜色，可忽略
	res/
		short_anser.txt 包含一些简短的问答
	src/
		main.cpp 主函数，可以在这里添加自定义测试
		test.cpp 默认测试案例，原则上不需要修改
		utils.cpp 斯坦福 C++ 库提取的一些使用工具，可忽略
</code></pre></div></div>

<p>初始项目代码已经完成了部分文档的编写，这些文档包含了大量零碎的知识点，需要参考 C++ 在线文档尝试理解每个部分的意思，特别是 <code class="language-plaintext highlighter-rouge">hashmap.h</code> 和 <code class="language-plaintext highlighter-rouge">hashmap_impl.h</code> 两个文件。</p>

<p>只有理解了这些代码的设计意图，才能更好地完成后续任务。</p>

<h2 id="milestone-1实现-rehash">Milestone 1：实现 <code class="language-plaintext highlighter-rouge">rehash()</code></h2>

<p><em>本小节视频讲解时间段 <a href="https://h8pqt7tpdf.feishu.cn/file/IssCb8xvxoKuGNxxPz1coyB9nrh" target="_blank">00:13:34-00:22:55</a></em></p>

<p>第一个需要你完成的函数是 <code class="language-plaintext highlighter-rouge">rehash</code>，这个函数的实现需要你对链表的使用有一定的了解，这在 <a href="https://cs101.stickmind.com/" target="_blank">CS101</a> 的作业中已经有了大量的练习。</p>

<p>和 <a href="https://cs101.stickmind.com/" target="_blank">CS101</a> 链表作业的实现要求类似，<code class="language-plaintext highlighter-rouge">rehash</code> 的实现同样<strong>禁止分配任何内存</strong>，还要避免内存泄漏。只能利用现有的节点，通过指针的灵活操作来实现调整节点的目的。在实现的过程中，记得参考 <code class="language-plaintext highlighter-rouge">insert</code> 和 <code class="language-plaintext highlighter-rouge">erase</code> 的现有实现。</p>

<p>默认提供了 <code class="language-plaintext highlighter-rouge">1A</code> 和 <code class="language-plaintext highlighter-rouge">1B</code> 两个测试，前者为外部测试，后者为内部测试。内部测试较为粗糙，有一定的失败机率，偶尔发生不用担心。除了这些测试，你还可以添加自己的测试案例。良好的测试，能够让你对自己的代码更有信心。</p>

<p>这个任务完成后，你将对初始项目的代码有更深刻的了解。</p>

<h2 id="milestone-2运算符重载和常量正确">Milestone 2：运算符重载和常量正确</h2>

<p>此部分你将实现 4 个运算符重载，还有 1 个常量接口问题需要解决。在实现的过程中，记得修改 <code class="language-plaintext highlighter-rouge">test_settings.h</code> 文件，依次开启相关的测试案例。</p>

<h3 id="索引-">索引 <code class="language-plaintext highlighter-rouge">[]</code></h3>

<p>索引操作接收一个<strong>键</strong>（key），并返回<strong>映射值</strong>（mapped value）的一个引用。索引操作需要支持自动插入，也就是说，当键不存在时，将创建一个默认的映射值，一起组成一个新的<strong>键/映射对</strong>（key/mapped pair）插入元素。</p>

<h3 id="流插入-">流插入 <code class="language-plaintext highlighter-rouge">&lt;&lt;</code></h3>

<p>流插入操作将 <code class="language-plaintext highlighter-rouge">HashMap</code> 的内容输出到输出流中，输出格式可以模仿斯坦福库中的 <code class="language-plaintext highlighter-rouge">HashMap</code>：</p>

<ul>
  <li>使用类似 <code class="language-plaintext highlighter-rouge">{key1: mapped1, key2: mapped2, ...}</code> 的格式输出所有的元素</li>
  <li>输出顺序没有要求，这符合无序映射的特性</li>
</ul>

<p>更重要的是，流插入操作支持链式插入，例如 <code class="language-plaintext highlighter-rouge">cout &lt;&lt; map1 &lt;&lt; map2 &lt;&lt; endl</code>。思考这一点在实现中如何体现。</p>

<h3 id="相等--和不相等-">相等 <code class="language-plaintext highlighter-rouge">==</code> 和不相等 <code class="language-plaintext highlighter-rouge">!=</code></h3>

<p>如果两个对象的键/映射对完全相同，即包含完全相同的元素，则两个对象相等；反之，则不相等。</p>

<p>如果<strong>桶</strong>（bucket）大小或元素在桶中的位置不一致，不影响判断结果，只以元素本身作比较。</p>

<h3 id="常量正确">常量正确</h3>

<p>初始代码或你自己添加的成员函数可能不符合常量正确（const correctness）的要求。这一步的任务是找出这些接口并修复。</p>

<h2 id="milestone-3拷贝语义和移动语义">Milestone 3：拷贝语义和移动语义</h2>

<p>初始代码已经包含了<strong>构造函数</strong>和<strong>析构函数</strong>；这部分需要你实现拷贝语义和移动语义的几个接口：</p>

<ul>
  <li>拷贝构造函数</li>
  <li>拷贝赋值运算符</li>
  <li>移动构造函数</li>
  <li>移动赋值运算符</li>
</ul>

<p>拷贝操作需要创建给定对象的相同副本；移动操作需要将给定对象的内容转嫁给当前对象。两个实现都要避免内存泄漏，并尽可能安全高效地实现代码。</p>

<p>关于测试案例，<code class="language-plaintext highlighter-rouge">3A</code> 用于测试拷贝操作，<code class="language-plaintext highlighter-rouge">3B</code> 用于测试移动操作，<code class="language-plaintext highlighter-rouge">3C</code> 用于确认移动操作的效率，实现过程中要避免拷贝。</p>

<h2 id="milestone-4问答题">Milestone 4：问答题</h2>

<p>在 <code class="language-plaintext highlighter-rouge">res/short_answers.txt</code> 中有 10 个小问题需要你思考。这些问题有助于你更好地理解一些细节问题。</p>

<h2 id="milestone-5列表初始化范围构造器可选">Milestone 5：列表初始化/范围构造器（可选）</h2>

<h2 id="milestone-6迭代器可选">Milestone 6：迭代器（可选）</h2>]]></content><author><name>薛浩</name><email>xuehao0618@outlook.com</email></author><category term="CS2" /><summary type="html"><![CDATA[本文改编自斯坦福 CS106L 的一份作业，详细的背景介绍可以参考官方文档。]]></summary></entry><entry><title type="html">一起来写 vector 容器</title><link href="http://localhost:8000/cs2/2022/08/22/let-us-create-a-vector.html" rel="alternate" type="text/html" title="一起来写 vector 容器" /><published>2022-08-22T00:00:00+08:00</published><updated>2022-08-22T00:00:00+08:00</updated><id>http://localhost:8000/cs2/2022/08/22/let-us-create-a-vector</id><content type="html" xml:base="http://localhost:8000/cs2/2022/08/22/let-us-create-a-vector.html"><![CDATA[<p>容器是一种保存值的集合的数据结构。C 提供了较原始的内建容器，例如数组和结构体；<code class="language-plaintext highlighter-rouge">C++</code> 标准库在此基础上提供了更丰富、更强大的容器。</p>

<p>标准库还有很多有用的算法和迭代器，在开发程序过程中，应该优先选用这些工具。虽然 <code class="language-plaintext highlighter-rouge">C++</code> 标准库提供了这些容器，但是 <code class="language-plaintext highlighter-rouge">C++</code> 也为用户提供了编写自己容器的方法——也就是说，<code class="language-plaintext highlighter-rouge">C++</code> 没有将容器的设计限定到某种单一的方法上。</p>

<p>通过研究斯坦福 <code class="language-plaintext highlighter-rouge">C++</code> 库，我们发现了一个现象。早期教材配套库在设计 <code class="language-plaintext highlighter-rouge">Vector</code> 时，使用的是基于动态数组的相对原始的设计策略；而最新版采用的策略，却是基于标准库 <code class="language-plaintext highlighter-rouge">std::vector</code> 进行的扩展，增加了很多参数方面的检查，为初学者的使用提供了更多方便。这也给了我们一个启示：即便标准库没有我们需要的工具，也应该基于标准库进行扩展，而不是采用原始的方式编码。</p>

<p>但作为练习，我们接下来将要实现一个基于动态数组的 <code class="language-plaintext highlighter-rouge">vector</code>，接口类似标准库的 <a href="https://en.cppreference.com/w/cpp/container/vector" target="_blank">std::vector</a>。通过这几个小任务，我们尝试构建一个小型的 <code class="language-plaintext highlighter-rouge">C++</code> 知识框架，目的是能够写出一个兼容标准库（STL-compliant）的容器，体会 <code class="language-plaintext highlighter-rouge">C++</code> 标准库容器的开发过程。所谓兼容标准库，就是让我们的容器能够复用大量现有的标准库算法。</p>

<p>这里采用的开发策略是逐步求精。也就是说，先实现一个基本的容器，逐步添加模板、重载等技术，而不用太关心标准库的细节。在基本实现完成后，再尝试添加迭代器等技术，以便让容器可以兼容标准库的框架。</p>

<h2 id="task-1类-class">Task 1：类 class</h2>
<blockquote>
  <ul>
    <li><a href="https://isocpp.org/wiki/faq/classes-and-objects" target="_blank">Classes and Objects, C++ FAQ</a></li>
    <li>C++ Primer，Ch 7</li>
  </ul>
</blockquote>

<p><em>本小节视频讲解时间段 <a href="https://h8pqt7tpdf.feishu.cn/file/IssCb8xvxoKuGNxxPz1coyB9nrh" target="_blank">00:24:05-00:35:36</a></em></p>

<p>在 <code class="language-plaintext highlighter-rouge">C++</code> 中，我们通过类来定义自己的数据类型。用类来表示概念，可以使我们更容易编写、调试和修改程序。在这个任务中，我们将实现一个基本的 <code class="language-plaintext highlighter-rouge">vector</code> 接口：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">vector</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// Special Member Functions</span>
    <span class="n">vector</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">capacity</span> <span class="o">=</span> <span class="mi">10</span><span class="p">);</span>
    <span class="o">~</span><span class="n">vector</span><span class="p">();</span>

    <span class="c1">// Element Access</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">);</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">front</span><span class="p">();</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">back</span><span class="p">();</span>

    <span class="c1">// Iterators</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">begin</span><span class="p">();</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">end</span><span class="p">();</span>

    <span class="c1">// Capacity</span>
    <span class="kt">bool</span> <span class="n">empty</span><span class="p">();</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">();</span>
    <span class="kt">size_t</span> <span class="n">capacity</span><span class="p">();</span>

    <span class="c1">// Modifiers</span>
    <span class="kt">void</span> <span class="n">clear</span><span class="p">();</span>
    <span class="kt">void</span> <span class="n">reserve</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">insert</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">erase</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">pos</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">pop_back</span><span class="p">();</span>

<span class="nl">private:</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">m_elems</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">m_capacity</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">m_size</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<h3 id="命名空间">命名空间</h3>
<blockquote>
  <p>C++ Primer，Ch 18.2</p>
</blockquote>

<p>当程序开发用到多个库时，难免会发生名称冲突的情况。传统的方式是通过定义特殊的命名规范来避免冲突，比如 <code class="language-plaintext highlighter-rouge">m_data</code> 表示成员变量，<code class="language-plaintext highlighter-rouge">p_arr</code> 表示指针数组。</p>

<p><code class="language-plaintext highlighter-rouge">C++</code> 还提供了<strong>命名空间</strong>（namespace）来防止名称冲突。每个命名空间都是一个作用域，变量名必须通过命名空间才可识别。</p>

<p>由于我们的 <code class="language-plaintext highlighter-rouge">vector</code> 和标准库中的容器同名，所以，此处发生了名称冲突。这里可以使用 <code class="language-plaintext highlighter-rouge">namespace</code> 增加 <code class="language-plaintext highlighter-rouge">cs101</code> 名称限定符，在使用时也需要 <code class="language-plaintext highlighter-rouge">cs101::vector</code> 加以限定。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">cs101</span> <span class="p">{</span>
    <span class="k">class</span> <span class="nc">vector</span> <span class="p">{</span> 
        <span class="p">...</span> <span class="c1">// starting from here</span>
	<span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="动态数组">动态数组</h3>
<blockquote>
  <p>C++ Primer，Ch 12.2</p>
</blockquote>

<p>认识一个类，应该先从 <code class="language-plaintext highlighter-rouge">private</code> 部分开始，了解其底层表示。参考标准库，我们使用<strong>动态数组</strong>作为底层的表示结构。除此之外，我们还有必要记录数组的分配大小和逻辑大小，方便其他接口的使用。虽然分配大小可以通过数组名和元素类型计算得出，但为了使用上的便利和不必要的计算，我们增加这个成员。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">private:</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">m_elems</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">m_capacity</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">m_size</span><span class="p">;</span>
</code></pre></div></div>

<pre><code class="language-note">大多数应用应该使用标准库容器而不是动态数组。使用容器更为简单，更不容易出现内存管理错误，并且可能有更好的性能。
</code></pre>

<h3 id="构造析构函数">构造/析构函数</h3>

<p><strong>默认构造函数</strong>（default constructor）没有参数，标准库 <code class="language-plaintext highlighter-rouge">vector</code> 默认不分配数组；我们的 <code class="language-plaintext highlighter-rouge">vector</code> 使用默认参数，不提供参数时将分配 10 个元素的数组。此处的构造函数，既充当了默认构造函数的功能，又充当了<strong>带参数构造函数</strong>的功能。</p>

<p><strong>析构函数</strong>（destructor）此处只需要删除动态数组，注意使用 <code class="language-plaintext highlighter-rouge">delete[]</code>。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">capacity</span> <span class="o">=</span> <span class="mi">10</span><span class="p">);</span>
<span class="o">~</span><span class="n">vector</span><span class="p">();</span>
</code></pre></div></div>

<p>其他一些查询函数的实现较为简单：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="nf">empty</span><span class="p">();</span>
<span class="kt">size_t</span> <span class="nf">size</span><span class="p">();</span>
<span class="kt">size_t</span> <span class="nf">capacity</span><span class="p">();</span>
</code></pre></div></div>

<h3 id="指针和迭代器">指针和迭代器</h3>
<blockquote>
  <p>Textbook，Ch 20.6</p>
</blockquote>

<p><strong>迭代器</strong>（iterator）是指针（pointer）的泛化或抽象，允许 <code class="language-plaintext highlighter-rouge">C++</code> 程序（特别是标准库算法）<strong>以统一的方式</strong>操作不同的数据结构。为了正确、高效地操作不同的数据结构，<code class="language-plaintext highlighter-rouge">C++</code> 标准不仅规定了迭代器的接口，还规定了迭代器的语义和其复杂度。</p>

<p>由于数组结构的特殊性，此处为了开发的简便，只用了裸指针的别名表示迭代器：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">iterator</span> <span class="o">=</span> <span class="kt">int</span><span class="o">*</span><span class="p">;</span>
</code></pre></div></div>

<p>为了支持基于范围的 for 循环，我们需要实现 <code class="language-plaintext highlighter-rouge">begin</code> 和 <code class="language-plaintext highlighter-rouge">end</code>。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">::</span><span class="n">iterator</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">intVec</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">itr</span> <span class="o">&lt;</span> <span class="n">intVec</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">itr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">itr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">item</span><span class="o">:</span> <span class="n">vec</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="动态扩容">动态扩容</h3>

<p>插入操作 <code class="language-plaintext highlighter-rouge">insert</code> 的第一次尝试，无扩容操作。使用策略是分配一个足够大的数组，防止溢出；但缺点是造成了空间的浪费。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="o">::</span><span class="n">iterator</span> <span class="n">vector</span><span class="o">::</span><span class="n">insert</span><span class="p">(</span><span class="n">iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 移动 pos 后面的元素，留出插入空间</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">i</span> <span class="o">=</span> <span class="n">end</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">pos</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 插入 value</span>
    <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="c1">// 更新 m_size</span>
    <span class="n">m_size</span><span class="o">++</span><span class="p">;</span>
    <span class="c1">// 返回插入位置的指针</span>
    <span class="k">return</span> <span class="n">pos</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>我们需要实现一种新的策略，在程序运行过程中，可以根据元素的数量动态地调整内存的空间，即<strong>动态分配</strong>（dynamical allocation）。</p>

<p>参考标准库文档编写 <a href="https://en.cppreference.com/w/cpp/container/vector/reserve" target="_blank">std::vector&lt;T,Allocator&gt;::reserve</a> 方法，实现动态数组内存管理：</p>

<ul>
  <li>当 <code class="language-plaintext highlighter-rouge">n</code> 小于等于当前 <code class="language-plaintext highlighter-rouge">capacity</code> 时，不作任何操作</li>
  <li>当 <code class="language-plaintext highlighter-rouge">n</code> 大于当前 <code class="language-plaintext highlighter-rouge">capacity</code> 时，增加 <code class="language-plaintext highlighter-rouge">capacity</code> 以便可以容纳 <code class="language-plaintext highlighter-rouge">n</code> 个元素</li>
</ul>

<pre><code class="language-tip">**扩容系数 Growth factor**

为了避免多次调整大小产生的成本，动态数组会大幅度调整大小。动态数组的扩容系数取决于几个因素，包括时空权衡和内存分配器本身使用的算法。在 `C++` 中，一般选择的扩容系数为 2。

借助摊销分析，扩容操作的平均时间复杂度为 $O(1)$，这是教学中的一个常见示例，参考教材 12.9 节。
</code></pre>

<p>参考标准库文档编写 <a href="https://en.cppreference.com/w/cpp/container/vector/insert" target="_blank">std::vector&lt;T,Allocator&gt;::insert</a> 方法，注意参数 <code class="language-plaintext highlighter-rouge">pos</code> 为迭代器（裸指针）：</p>

<ul>
  <li>在 <code class="language-plaintext highlighter-rouge">pos</code> 指向的位置插入 <code class="language-plaintext highlighter-rouge">value</code> 值</li>
  <li>必要时需要扩容，可以利用 <code class="language-plaintext highlighter-rouge">reserve</code> 方法</li>
  <li>返回 <code class="language-plaintext highlighter-rouge">pos</code> 迭代器，以便需要时可以访问插入的元素</li>
  <li>查看测试案例，了解客户端用法</li>
</ul>

<h2 id="task-2模板-template">Task 2：模板 template</h2>
<blockquote>
  <p>C++ Primer，Ch 16</p>
</blockquote>

<p><em>本小节视频讲解时间段 <a href="https://h8pqt7tpdf.feishu.cn/file/IssCb8xvxoKuGNxxPz1coyB9nrh" target="_blank">00:35:36-00:47:48</a></em></p>

<p>面向对象语言，例如 Python，所有类型都是动态的，类型在运行时确认；<code class="language-plaintext highlighter-rouge">C++</code> 使用模板技术，类型在编译期就能够确认。在这个任务中，我们将使用模板技术，让 <code class="language-plaintext highlighter-rouge">vector</code> 容器支持不同的类型。</p>

<p>模板是泛型编程的基础，是创建类或函数的公式。我们已经接触过函数模板，模板可以看作是<strong>以类型为参数的编译期函数</strong>。</p>

<p>当编译器遇到一个模板定义时，并不会生成代码。只有当代码中实例化一个特定版本时，编译器才会生成代码。这一特性将影响我们如何组织代码，本课程中采用<strong>定义和实现放在同一个头文件中</strong>的策略。</p>

<p>类模板的定义和函数模板类似，但使用上有所区别，类模板必须使用前括号明确类型信息，否则编译器无法自动推断模板类型。</p>

<p>类模板定义以 <code class="language-plaintext highlighter-rouge">template</code> 开始，后面尖括号包含类模板参数列表。根据 <code class="language-plaintext highlighter-rouge">C++</code> 标准要求，类模板定义中需要添加 <code class="language-plaintext highlighter-rouge">value_type</code> 成员类型，所以在后续的接口声明中，可以用此别名替换所有类型：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">namespace</span> <span class="n">cs101</span> <span class="p">{</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>     <span class="c1">// 类模板定义</span>
<span class="k">class</span> <span class="nc">vector</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span> <span class="c1">// 类成员定义（标准要求）</span>
	
	<span class="n">value_type</span> <span class="o">&amp;</span><span class="n">at</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">value_type</span> <span class="o">&amp;</span><span class="n">front</span><span class="p">();</span>
	<span class="n">value_type</span> <span class="o">&amp;</span><span class="n">back</span><span class="p">();</span>

<span class="nl">private:</span>
    <span class="p">...</span>
    
<span class="p">};</span> <span class="c1">// end of vector</span>

<span class="p">}</span> <span class="c1">// end of cs101</span>
</code></pre></div></div>

<p>不同类型的类，拥有不同类型的成员函数实现。为了实现成员函数的模板化，同样需要以 <code class="language-plaintext highlighter-rouge">template</code> 开始：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">vector</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">capacity</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">m_elems</span><span class="p">{</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">capacity</span><span class="p">]},</span> <span class="n">m_capacity</span><span class="p">{</span><span class="n">capacity</span><span class="p">},</span> <span class="n">m_size</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span> <span class="p">{}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> 
<span class="kt">bool</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">empty</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当成员函数返回值包含类模板成员名时，需要结合模板和限定名来访问。例如，返回值为 <code class="language-plaintext highlighter-rouge">value_type</code> 需要按如下代码处理：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">typename</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">value_type</span> <span class="o">&amp;</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">at</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">index</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="task-3常量正确-const-correctness">Task 3：常量正确 const-correctness</h2>
<blockquote>
  <p><a href="https://isocpp.org/wiki/faq/const-correctness" target="_blank">Const Correctness, C++ FAQ (isocpp.org)</a></p>
</blockquote>

<p><em>本小节视频讲解时间段 <a href="https://h8pqt7tpdf.feishu.cn/file/IssCb8xvxoKuGNxxPz1coyB9nrh" target="_blank">00:48:00-01:01:00</a></em></p>

<p>使用 <code class="language-plaintext highlighter-rouge">const</code> 声明对象（或者对象引用、对象指针），则表明对象的值无法改变。在目前的实现中，我们的 <code class="language-plaintext highlighter-rouge">vector</code> 容器还不支持常量接口。如果定义这样的常量对象，编译器将禁止调用 <code class="language-plaintext highlighter-rouge">vector</code> 的所有方法。</p>

<p>对于一些查询接口，例如 <code class="language-plaintext highlighter-rouge">size()</code>、<code class="language-plaintext highlighter-rouge">isEmpty()</code> 等，本身并不会改变对象的值。如果也禁用这些接口，类的通用性将变差。对于此类接口，可以使用 <code class="language-plaintext highlighter-rouge">const</code> 进行标记，这样不管使常量对象还是非常量对象都可以调用此类接口。</p>

<p>以下接口仅作查询操作，只需要在声明后面添加关键字：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">capacity</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</code></pre></div></div>

<p>相应的实现也需要同样的调整：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">size_t</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">m_size</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>而像 <code class="language-plaintext highlighter-rouge">at()</code>、<code class="language-plaintext highlighter-rouge">front()</code> 这样的接口，既可以用于查询操作又可以用于修改操作。这类接口需要同时实现两个版本：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">value_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">);</span>
<span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">at</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</code></pre></div></div>

<p>在使用迭代器时，如果不修改对象的内容，经常使用如下语法：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span> <span class="n">item</span><span class="o">:</span> <span class="n">vec</span><span class="p">){</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>此时也需要添加常量迭代器，以及常量版本的 <code class="language-plaintext highlighter-rouge">begin()</code>、<code class="language-plaintext highlighter-rouge">end()</code> 接口：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="n">iterator</span> <span class="o">=</span> <span class="n">T</span><span class="o">*</span><span class="p">;</span>
<span class="k">using</span> <span class="n">const_iterator</span> <span class="o">=</span> <span class="k">const</span> <span class="n">T</span><span class="o">*</span><span class="p">;</span>

<span class="n">iterator</span> <span class="nf">begin</span><span class="p">();</span>
<span class="n">iterator</span> <span class="nf">end</span><span class="p">();</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</code></pre></div></div>

<pre><code class="language-note">对于上述 `at()` 这样的接口，在实现过程中我们发现函数体内的代码完全一致。为了避免 `const` 和 `non-const` 成员函数中代码重复，参考 Scott Meyer 在《Effective C++, 3rd》中条款 3 介绍的写法。
</code></pre>

<h2 id="task-4运算符重载-operator-overloading">Task 4：运算符重载 operator overloading</h2>
<blockquote>
  <ul>
    <li><a href="https://isocpp.org/wiki/faq/operator-overloading" target="_blank">Operator Overloading, C++ FAQ (isocpp.org)</a></li>
    <li>C++ Primer，Ch 14</li>
  </ul>
</blockquote>

<p><em>本小节视频讲解时间段 <a href="https://h8pqt7tpdf.feishu.cn/file/Kh7obHaxNoxsGWxfziqcUfFTn3d" target="_blank">00:11:10-00:31:08</a></em></p>

<p>内置类型支持大量的运算符，这些运算符同样可以用于自定义的类型，并重新赋予新的含义，例如字符串的 <code class="language-plaintext highlighter-rouge">+</code> 运算符表示连接两个字符串，而不是数值类型的加法操作。这个任务中，我们将让 <code class="language-plaintext highlighter-rouge">vector</code> 容器支持一些运算符操作。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 注意要保持常量正确</span>
<span class="n">value_type</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">);</span>
<span class="k">const</span> <span class="n">value_type</span> <span class="o">&amp;</span><span class="k">operator</span><span class="p">[](</span><span class="kt">size_t</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// 注意重载为全局函数</span>
<span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span> <span class="o">&amp;</span><span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">vec</span><span class="p">);</span>
</code></pre></div></div>

<p>运算符本质仍然是函数，函数名由关键字 <code class="language-plaintext highlighter-rouge">operator</code> 和运算符构成，例如 <code class="language-plaintext highlighter-rouge">str1 + str2</code> 会转换为类似 <code class="language-plaintext highlighter-rouge">operator+(str1, str2)</code>  这样的函数进行处理。运算符函数和普通函数一样，也有返回值、参数列表、函数体等内容。</p>

<p>关于运算符重载，标准也作了一些限制（参考 <a href="https://en.cppreference.com/w/cpp/language/operators" target="_blank">Restrictions</a>）。</p>

<p>方法既可以设计为成员函数，也可以设计为全局函数。 对于运算符重载，有些应该设计为成员函数，比如 <code class="language-plaintext highlighter-rouge">=</code>、<code class="language-plaintext highlighter-rouge">[]</code>；有些推荐设计为全局函数，比如 <code class="language-plaintext highlighter-rouge">&lt;&lt;</code>、<code class="language-plaintext highlighter-rouge">&gt;&gt;</code> 等。这些约定，标准文档也作了说明，比如 <a href="https://en.cppreference.com/w/cpp/language/operator_member_access" target="_blank">Member access operators</a> 推荐的原型示例。</p>

<p>将模板类接口设计为全局函数时，需要解决两个问题。首先，全局函数无法访问类的私有成员，解决这个问题可以使用 <code class="language-plaintext highlighter-rouge">friend</code> 关键字标记函数声明，并添加到类的接口中。其次，模板函数在类中声明时，仍然需要使用 <code class="language-plaintext highlighter-rouge">template</code> 模板。此时可能会遇到类型名冲突的问题，解决方法是在类中使用另一个名称标记模板的 <code class="language-plaintext highlighter-rouge">typename</code> 以避免和类模板类型名称冲突。参考 <a href="https://stackoverflow.com/questions/4660123/overloading-friend-operator-for-template-class" target="_blank">overloading friend operator« for template class</a></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">K</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">M</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">H</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">hash</span><span class="o">&lt;</span><span class="n">K</span><span class="p">&gt;</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">HashMap</span> <span class="p">{</span>
    <span class="p">...</span>
    
    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">K2</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">M2</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">H2</span><span class="p">&gt;</span>
    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">HashMap</span><span class="o">&lt;</span><span class="n">K2</span><span class="p">,</span> <span class="n">M2</span><span class="p">,</span> <span class="n">H2</span><span class="o">&gt;&amp;</span> <span class="n">map</span><span class="p">);</span>

    <span class="p">...</span>
<span class="p">};</span>
</code></pre></div></div>

<h2 id="task-5拷贝语义-copy-semantics">Task 5：拷贝语义 copy semantics</h2>
<blockquote>
  <p>C++ Primer，Ch 13</p>
</blockquote>

<p><em>本小节视频讲解时间段 <a href="https://h8pqt7tpdf.feishu.cn/file/Kh7obHaxNoxsGWxfziqcUfFTn3d" target="_blank">00:31:08-01:04:22</a></em></p>

<p>在 CS101 的类实现中，我们只强调了如何创建对象（构造函数）和如何销毁对象（析构函数）。除了对象的创建和销毁，我们还需要控制对象的拷贝和赋值。这个任务中，我们将实现拷贝构造函数和拷贝赋值运算符。</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">);</span>               <span class="c1">// copy constructor</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">);</span> <span class="c1">// copy assignment</span>
</code></pre></div></div>

<p>下面的两种用法分别演示了拷贝构造函数和拷贝赋值运算符的使用场景和区别：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// create vec1</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">vec1</span><span class="p">;</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"A"</span><span class="p">);</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"B"</span><span class="p">);</span>
<span class="n">vec1</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">"C"</span><span class="p">);</span>

<span class="c1">// copy constructor: create vec2 using the contents of vec1</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">vec2</span> <span class="o">=</span> <span class="n">vec1</span><span class="p">;</span>

<span class="c1">// create vec3 with default value</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">vec3</span><span class="p">;</span>
<span class="c1">// copy assignment: replace vec3 using the contents of vec1</span>
<span class="n">vec3</span> <span class="o">=</span> <span class="n">vec1</span><span class="p">;</span>
</code></pre></div></div>

<p>理解两者的工作机制将有助于后续的代码实现。拷贝构造函数是使用另一个对象的值来创建一个新的对象；而拷贝赋值运算符操作的是一个已有的对象，只是利用另一个对象的值替换已有对象的内容。</p>

<p><a href="https://en.cppreference.com/w/cpp/language/rule_of_three" target="_blank">三法则</a>（rule of three）的要求是，假如类实现了下面任意一个成员函数，则其他两个也必须实现：</p>

<ul>
  <li>析构函数</li>
  <li>拷贝构造函数</li>
  <li>赋值运算符</li>
</ul>

<p>我们的 <code class="language-plaintext highlighter-rouge">vector</code> 已经包含了析构函数，所以此时编译器会自动为我们生成其他两个。由于在类中涉及到动态内存分配，这些自动生成的成员函数并不能满足内存管理的要求。底层原因是，编译器和运行时只能管理栈内存，所以堆内存并不会得到正确处理，因而造成了内存问题。</p>

<p>实现拷贝构造函数和拷贝赋值运算符，可以参考上述文档的示例。需要注意的是，拷贝赋值运算符可能会发生自我拷贝，例如 <code class="language-plaintext highlighter-rouge">vec1 = vec1</code>，此时需要作一些特别的处理。</p>

<h2 id="task-6移动语义-move-semantics">Task 6：移动语义 move semantics</h2>
<blockquote>
  <p>C++ Primer，Ch 13</p>
</blockquote>

<h3 id="左值引用-vs-右值引用">左值引用 vs 右值引用</h3>

<p>我们已经了解过引用在函数参数等场景下的应用，现在我们将这一概念继续细化。目前接触过的引用，称为<strong>左值引用</strong>：</p>

<ul>
  <li>语法格式为 <code class="language-plaintext highlighter-rouge">T&amp;</code>，这里 <code class="language-plaintext highlighter-rouge">T</code> 为类型名</li>
  <li>运算符 <code class="language-plaintext highlighter-rouge">=</code> 右边的表达式必须是命名变量，即在调试器面板中可以看到这个变量名和值</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">num</span><span class="p">{</span><span class="mi">3</span><span class="p">};</span>
<span class="kt">int</span><span class="o">&amp;</span> <span class="n">lref</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
</code></pre></div></div>

<p>以下写法违背了上述第二条规则，虽然函数返回整型，但这个返回值是没有名称的：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fn</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">3</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span><span class="o">&amp;</span> <span class="n">lref</span> <span class="o">=</span> <span class="n">fn</span><span class="p">();</span>       <span class="c1">// error</span>
</code></pre></div></div>

<p>函数的返回值是一个临时的值，如果没有变量进行存储，系统将会自动丢弃该值。所以，对于上述写法可以作如下改写：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fn</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">3</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">fn</span><span class="p">();</span>       <span class="c1">// copy ctor</span>
<span class="kt">int</span><span class="o">&amp;</span> <span class="n">lref</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</code></pre></div></div>

<p>以上对左值引用的修改，在函数调用的使用中，影响更大。我们使用引用的动机是避免拷贝，提升效率，但增加的临时变量 <code class="language-plaintext highlighter-rouge">temp</code> 却再次发生了拷贝。</p>

<p>为了解决这个问题，<code class="language-plaintext highlighter-rouge">C++</code> 又推出了一个新的引用类型，称为<strong>右值引用</strong>：</p>

<ul>
  <li>语法格式为 <code class="language-plaintext highlighter-rouge">T&amp;&amp;</code>，这里 <code class="language-plaintext highlighter-rouge">T</code> 为类型名</li>
  <li>用于绑定临时对象，避免销毁</li>
</ul>

<p>左值引用的是一个对象的变量，而右值引用的是一个临时对象的表达式值。因为变量通常都是在 <code class="language-plaintext highlighter-rouge">=</code> 的左边，而临时对象的表达式值通常都是在 <code class="language-plaintext highlighter-rouge">=</code> 右边，所以左值/右值的命名在理解上也较为直接。</p>

<p>有了这个新技术，我们就可以更好地改写上述问题，避免拷贝：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">fn</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">3</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">rref</span> <span class="o">=</span> <span class="n">fn</span><span class="p">();</span>       <span class="c1">// oook</span>
</code></pre></div></div>

<p>另外，左值是无法使用右值引用的，如果强行进行绑定，需要借助 <code class="language-plaintext highlighter-rouge">std::move</code> 来操作：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">num</span><span class="p">{</span><span class="mi">3</span><span class="p">};</span>
<span class="kt">int</span><span class="o">&amp;&amp;</span> <span class="n">rref</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">num</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="拷贝-vs-移动">拷贝 vs 移动</h3>

<p>目前我们已经完成了对象的拷贝控制。将一个对象的值拷贝给另一个对象，对于基本类型来说，这是唯一合理的方式；但对于容器来说，特别是元素数量很多的情况，这样的拷贝将会消耗大量计算资源。</p>

<p>在某些场景下，避免拷贝并不会影响程序的逻辑。例如，交换两个对象的内容，并不需要维护一个临时容器，将所有元素拷贝两次。现实生活中也有类似的比喻，比如房产交易并不需要将房子搬来搬去，而只需要变更双方名下的房屋地址就可以完成。</p>

<p><code class="language-plaintext highlighter-rouge">C++</code> 增加了移动的概念来支持这一目的，通过实现移动构造函数和移动赋值运算符，我们可以为类增加移动控制。</p>

<p><a href="https://en.cppreference.com/w/cpp/language/rule_of_three" target="_blank">五法则</a>（rule of five）的要求是，一旦实现三法则，编译器将无法为我们生成移动构造函数和移动赋值运算符。所以，对于我们的 <code class="language-plaintext highlighter-rouge">vector</code> 容器，此时还需要实现如下两个函数：</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">vector</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">);</span>                    <span class="c1">// move constructor</span>
<span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span><span class="n">other</span><span class="p">);</span>      <span class="c1">// move assignment</span>
</code></pre></div></div>

<h2 id="task-7-拷贝交换习语">Task 7: 拷贝交换习语</h2>
<blockquote>
  <p>C++ Primer，Ch 13</p>
</blockquote>

<p>涉及到资源管理的类，通常定义一个 <code class="language-plaintext highlighter-rouge">swap</code> 函数比较方便。交换两个对象，并不需要拷贝整个对象的内容，而只需要交换两个对象管理的内存指针。</p>

<p>通过 <code class="language-plaintext highlighter-rouge">swap</code> 函数需要定义两个版本，一个是成员函数，另一个是全局函数。<code class="language-plaintext highlighter-rouge">swap</code> 的内部实现需要交换所有的私有成员。</p>

<p>为了安全地处理异常，交换和移动都需要使用 <code class="language-plaintext highlighter-rouge">noexcept</code> 标记。这意味着如果发生任何异常，当前对象保持不变，避免在处理过程中破坏现有对象。</p>

<p>利用 <code class="language-plaintext highlighter-rouge">swap</code> 改写拷贝赋值、移动特殊函数，可以大大简化代码的实现，避免重复。</p>

<hr />
<p><em>Enjoy!</em></p>]]></content><author><name>薛浩</name><email>xuehao0618@outlook.com</email></author><category term="CS2" /><summary type="html"><![CDATA[容器是一种保存值的集合的数据结构。C 提供了较原始的内建容器，例如数组和结构体；C++ 标准库在此基础上提供了更丰富、更强大的容器。]]></summary></entry><entry><title type="html">斯坦福大学 CS 课程介绍</title><link href="http://localhost:8000/cs2/2022/01/16/stanford-cs-core.html" rel="alternate" type="text/html" title="斯坦福大学 CS 课程介绍" /><published>2022-01-16T00:00:00+08:00</published><updated>2022-01-16T00:00:00+08:00</updated><id>http://localhost:8000/cs2/2022/01/16/stanford-cs-core</id><content type="html" xml:base="http://localhost:8000/cs2/2022/01/16/stanford-cs-core.html"><![CDATA[<p>本文介绍斯坦福大学计算机科学相关课程以及学习建议，为广大自学朋友提供一些有价值的信息。</p>

<h2 id="cs106b程序设计抽象思维">CS106B：程序设计抽象思维</h2>

<p>CS106B 是<a href="https://www.cs.stanford.edu/bachelors/cs-minor" target="_blank">斯坦福大学 CS 核心课程</a>的第一门编程课，主要训练解决复杂问题的能力，课程的重点是介绍业界广泛使用的数据结构和算法。除此之外，课程还会特别训练计算机科学中最重要的思维——<strong>递归</strong>，通过对这些成熟案例的研究以启发学生的创造力。</p>

<p>对于从来没有接触过编程的同学，如果担心跟不上这门课，斯坦福还提供了先修课程 CS106A，主要训练抽象思维以及分治思想。如果说 CS106A 的重点是把程序写对，那么 CS106B 的重点就是把程序写好。</p>

<p>本项目的起源是之前春节在家，闲来无事，恰好看到了 CS106B 开课，所以就想着跟一下。每做完一份作业，无不感叹斯坦福老师的厉害之处，<strong>这是真正在“教”这件事上下足了功夫</strong>。</p>

<p>递归部分的作业比较烧脑，需要反复研究课件，反复揣摩每句话老师的用意。好在基本上保持每周完成一个 Assignment，后半部分相对简单些，基本上三天就能做完一份作业。</p>

<h3 id="环境搭建">环境搭建</h3>

<p>务必严格按照官网要求搭建环境，斯坦福 C++ 库常年更新，只有课程配套的库才能正常使用。本系列环境搭建可以参考官网，也可以在我的代码仓库里面查找。</p>

<p>成功运行后，Windows 在下面的位置会有编译好的斯坦福库，macOS 也有对应文件夹。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>C:\Users\用户名\AppData\Local\cs106
</code></pre></div></div>

<h3 id="配套教材">配套教材</h3>

<p>《<a href="https://web.stanford.edu/dept/cs_edu/resources/textbook/Reader-Beta-2012.pdf" target="_blank">Programming Abstractions in C++</a>》，中文版《<a href="https://book.douban.com/subject/27004881/" target="_blank">C++ 程序设计：基础、编程抽象与算法策略</a>》</p>

<p>随书配套的库 <a href="https://cppdoc.stickmind.com/" target="_blank">SimpleCxxLib</a> 和课程的不配套，需要单独配置。注意图形部分依赖 <code class="language-plaintext highlighter-rouge">spl.jar</code> 包，需要安装 JRE 环境。目前在最新版本 Ubuntu 下测试没有问题，喜欢 Linux 下开发的同学可以试一下。</p>

<h3 id="学习建议">学习建议</h3>

<p>Q：如何开始作业？</p>

<p>每个作业开始之前，仔细阅读相关的讲义和随堂代码，理解了课堂内容后再开始作业。每个作业，一方面是巩固课堂内容，另一方面是补充升华。如果作业内容涉及课堂知识，还需要反复看课件，通过作业才能真正领会课堂知识点的精髓。</p>

<p>Q：这门课讲数据结构和算法吗？</p>

<p>本课程重点不是设计数据结构和算法，而是 Problem Solving 问题求解。所以涉及到相关内容的，都会给出算法步骤，只需要按步骤转换成 C++ 就好了。有些算法不太理解，可以全网搜索相关内容，比如 BST 或 Graph 相关东西，明白之后再开始作业。</p>

<p>Q：有些题始终做不出来怎么办？</p>

<p>如果压力测试始终通不过，可以先放一放，做做其他题可能就有思路了。或者没事多看看作业说明，字里行间都会有老师埋下的伏笔，一旦领会某一句话就很容易做出来了。</p>

<p>Q：C++ 需要学到什么程度？</p>

<p>C++ 不需要精通，课堂提供的 C++ 技巧足够完成作业的。如果对 C++ 感兴趣，可以尝试学习 CS106L，尝试自己写一下斯坦福 C++ 库。</p>

<h3 id="其他说明">其他说明</h3>

<p>每次作业务必自己思考一周以上，不要去网上找别人的解答。特别是递归的解法，很多非常简洁，看了别人的解法就会少了很多学习体验，看懂不代表你已经掌握。斯坦福的题每年不会变太多，题量有限，且做且珍惜。</p>

<p>最后再给个老师的主页 <a href="https://www.keithschwarz.com/" target="_blank">Keith Schwarz</a>，推荐 Keith 版本的 CS106B，整整十个作业，详尽的单元测试，课程体验非常好。</p>

<h2 id="cs106l标准-c-编程">CS106L：标准 C++ 编程</h2>

<p>学完了 CS106B，对于 C++ 知识体系的了解，可以说已经（仅仅）涵盖了《C++ Primer》第一部分的内容；这些语法知识对于完成算法题已经完全够用了。</p>

<p>如果你想更深入的学习 C++，创建真实高效的应用，那么接下来应该学习的课程非 CS106L 莫属！下面就来谈谈这门课的学习。</p>

<h3 id="课程内容">课程内容</h3>

<p>直观上来讲，这门课的内容包含了《C++ Primer》剩下的几个部分，除此之外，这门课也会介绍一些最新标准的东西。整个课程主要会讲解以下几个主题：</p>

<ul>
  <li><strong>I/O</strong> 流的概念</li>
  <li><strong>STL</strong> 标准模板库的几个模块，除此之外，还会穿插一些 template function 相关的主题</li>
  <li><strong>数据抽象</strong> 关于如何抽象出自己的数据容器，C++ 提供了大量的工具（move semantics，template class，RAII，etc）</li>
  <li><strong>多线程</strong>、<strong>模板元编程</strong>等更高阶的技巧</li>
</ul>

<p>可以看出整个课程的脉络，基本和《C++ Primer》章节顺序类似。所以，这门课的最佳教材，除了配套的课程手册可以读一读之外，建议搭配《C++ Primer》一起享用，系统地建立一个 C++ 知识体系。</p>

<p>由此，我们也可以看出斯坦福教学体系的完备性。从 CS106B/CS106L 这两门课中剥离出 C++ 部分的内容，就相当于讲了一遍《C++ Primer》了。更值得称道的是，学完了 C++ 语法知识，如果你找不到合适的进阶项目练手，那么课上用的斯坦福 C++ 库便是很好的研究案例。</p>

<p>这也是笔者为什么偏爱斯坦福课程的原因，讲师及助教们真是太贴心了。在“教”这件事情上，不管是课程逻辑，还是随堂课件、配套练习，都下足了功夫。更难得的是，这些课程能够常年保持更新，紧贴业界需求！</p>

<h3 id="学习建议-1">学习建议</h3>

<p>如果没有学完 CS106B，不建议上手这门课。如果刚学完了 CS106B，其实也不太推荐直接开启这门课的学习。</p>

<p>推荐的学习顺序应该是，学完 CS106B 后，紧接着学习 CS107 或 CSAPP 这样的体系结构课程。在准备学习操作系统、网络这类专题课程之前，把 CS106L 完整过一遍，并用刚学到的 C++ 工具去解决操作系统、网络相关的编程问题，从而达到学以致用的目的。</p>

<p>体系结构的课程，一般都会用 C 语言和汇编。学完这样的课程，你的脑海里会逐渐浮现出软件工程的一些想法。经过这类课程的磨练，你不仅会知道计算机的局限性，还能够体会用 C 语言处理这样的问题会有多么的痛苦。</p>

<p>这个时候，C++ 的出现就仿佛是一道光，其内置的强大工具会带你脱离思维的苦海。怎么写出通用的函数（算法），怎么写出高度抽象还能参数化类型的类（数据结构）……这些是系统编程中绞尽脑汁需要解决的问题。而现在，解决这类问题的通用工具，在 C++ 中唾手可得！这怎么能不让人拍案叫绝！</p>

<p>学习的过程还是优先看课堂讲义，先理解随堂代码，并尝试手写一些斯坦福 C++ 库的接口。针对每一个主题，参考《C++ Primer》对应章节，补充缺失的内容。相信用不了 10 周，你便能建立一个关于 C++ 知识框架的心智模型。</p>

<h3 id="关于课件">关于课件</h3>

<p>视频已经整理并上传至<a href="https://www.bilibili.com/video/BV1K8411b7AU" target="_blank">B 站</a>主页，这是 <a href="https://www.youtube.com/playlist?list=PLCgD3ws8aVdolCexlz8f3U-RROA0s5jWA" target="_blank">Win19</a> 和 <a href="https://www.youtube.com/playlist?list=PLCgD3ws8aVdqxRtKN_skFumh9fV83WEaA" target="_blank">Win20</a> 两个学期的整合版。这两期的风格偏课堂讨论和现场写代码，所以这两期没有完整的课件。</p>

<p>这里笔者推荐看最新版本的 PPT，再结合公开的视频以及参考书，自行整理一份属于自己的 C++ 知识笔记。</p>

<h3 id="关于作业">关于作业</h3>

<p>作业部分建议直接尝试官网最新版即可，因为旧版课程是基于老版本的 Qt 环境，相关依赖不太好解决。另外，最新版基于 Linux 和 CMake，更贴近工业实践。</p>

<p>比较劝退的一点是，这些工具是基于 Linux 命令行的。所以，如前所述，笔者建议先学习 CS107 或 15-213 相关的系统课程，培养 Linux 环境下的开发习惯，特别是 GDB 调试的能力。这些能力也将在后续进阶课程中，给你带来极大的帮助。有这样的机会，让你尽早熟悉这些工具，何乐而不为呢？</p>

<hr />

<pre><code class="language-tip">❤️ **广而告之**

三个月还没学完这 CS106B/L？六个月了还在学？

别再浪费时间了，欢迎参加《[CS101：C++ 编程抽象思维](https://cs101.stickmind.com/){:target="_blank"}》
</code></pre>]]></content><author><name>薛浩</name><email>xuehao0618@outlook.com</email></author><category term="CS2" /><summary type="html"><![CDATA[本文介绍斯坦福大学计算机科学相关课程以及学习建议，为广大自学朋友提供一些有价值的信息。]]></summary></entry><entry><title type="html">Karel the Robot</title><link href="http://localhost:8000/cs1/2021/07/25/karel-the-robot.html" rel="alternate" type="text/html" title="Karel the Robot" /><published>2021-07-25T00:00:00+08:00</published><updated>2021-07-25T00:00:00+08:00</updated><id>http://localhost:8000/cs1/2021/07/25/karel-the-robot</id><content type="html" xml:base="http://localhost:8000/cs1/2021/07/25/karel-the-robot.html"><![CDATA[<p>最近整理了斯坦福 CS106A 的 Assignment 1，走进了一个叫做 Karel 的世界。</p>

<p>原本以为这只是一个简单的上手项目，激发学生对课程的兴趣而已，所以也没怎么重视。但是做完这几个题目之后，我的观念转变了，又回头仔细看了课程中的几个关键点。</p>

<p>Karel 是个经典的计算机科学教学项目，值得好好揣摩。设计这个课程的家伙，应该不仅自己掌握了计算机科学的精髓，而且还懂得怎样去做教学。所以，这真不是一个简简单单的上手项目，不然斯坦福每年也不会都用这个来教学。</p>

<p>在回看时，我仔细梳理了<strong>问题求解</strong>的过程，并深入思考了课程中反复提及的<strong>自顶向下分解策略</strong>（top-down decomposition）和函数调用的<strong>前置/后置条件</strong>（pre/post condition）。结合 Assignment 可以发现，作业的设计完全就是为了强化这些概念。</p>

<p>独立完成这些作业，一定会有一种豁然开朗的感觉。虽然说不清楚到底是啥感觉，但我知道，下次再遇到问题求解的时候，在大方向上，应该会更有把握，避免走太多弯路！</p>

<h2 id="问题">问题</h2>

<p>下面就以画棋盘那道题为例，分析一下问题求解的过程。</p>

<pre><code class="language-note">顺便提一下，这个题整整耗了我半天时间！原因嘛，就是没有应用课程中的关键点，没有按照老师教的方法来做……细品！
</code></pre>

<p>问题很简单，就是让 Karel 从起点，每放置完一个 Beeper 跳一个格子。问题的难点主要体现在两个方面：</p>

<ol>
  <li>只能使用 Karel 编程语言，不能使用 Java 里面的东西，特别是变量；</li>
  <li>地图不固定，不仅要满足多行多列，甚至单行单列，都要能够应付。</li>
</ol>

<pre><code class="language-info">**Karel 编程语言**

所谓 Karel 编程语言，就是 Karel 的世界了，它只包含有限的几个程序构件块。你想用高级一点的东西？对不起，没有！

Why？我觉得，只有这样的限制才会迫使你去思考：为了解决问题，编程语言的那些奇技淫巧是否真有必要？
</code></pre>

<h2 id="过程抽象">过程抽象</h2>

<p>这个策略，也可以称为<strong>逐步求精</strong>。但课件里，直译过来不是分而治之吗？至于为什么我不翻译为分而治之，是因为这个词，我把它给了更重要的递归策略。后续课程会专门训练递归思维。</p>

<p>对于棋盘这个问题，使用逐步求精的方法，很容易这么去思考：<strong>先让 Karel 从起点往上，走完所有的格子</strong>。暂且把放置 Beeper 的任务放一放，以便简化问题求解。那么首先需要解决的问题是：</p>

<blockquote>
  <p>Q: Karel 撞墙后如何移动到上一层？</p>

  <p>A: 我们可以用一个 <code class="language-plaintext highlighter-rouge">moveUp</code> 函数来抽象这个过程。</p>
</blockquote>

<p>继续细分，又有两种情况：一种是面朝东撞墙，另一种是面朝西撞墙。所以，我们可以使用一个 <code class="language-plaintext highlighter-rouge">if ... else ...</code> 条件分支，来区分这两种情况：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">private</span> <span class="kt">void</span> <span class="nf">moveUp</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">facingEast</span><span class="o">())</span> <span class="o">{</span>
    <span class="c1">// 向东的情况</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="c1">// 向西的情况</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>现在，我们再解决移动到上一格的问题。但在移动之前，其实还需要检测上方是否到顶。这就顺便解决了第二个问题：</p>

<blockquote>
  <p>Q: Karel 何时停止？</p>

  <p>A: 如果到顶了，那么不作任何操作；如果没到顶，那么移动到上一层并改变方向（即转身向上、走一步到上层、再转身改变方向，三个步骤一气呵成）。</p>
</blockquote>

<p>这一步无论向东还是向西，除了转动方向不同外，程序结构是一模一样的：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// pre-condition: 前方有障碍</span>
<span class="c1">// post-condition: 跳到上一格，并转身</span>
<span class="kd">private</span> <span class="kt">void</span> <span class="nf">moveUp</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">if</span> <span class="o">(</span><span class="n">facingEast</span><span class="o">())</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">leftIsClear</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// 对于这个条件检测</span>
      <span class="n">turnLeft</span><span class="o">();</span>
      <span class="n">move</span><span class="o">();</span>
      <span class="n">turnLeft</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">rightIsClear</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// 思考函数调用的时机问题</span>
      <span class="n">turnRight</span><span class="o">();</span>
      <span class="n">move</span><span class="o">();</span>
      <span class="n">turnRight</span><span class="o">();</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>注意，每次移动到上一层会改变之前的方向，可以看作是 Karel 又到了一个新的起点。这一步很重要，因为条件没变，所以可以复用很多过程。</p>

<p><code class="language-plaintext highlighter-rouge">moveUp</code> 函数的抽象过程是通用的，能够满足所有的情况。但要仔细思考函数调用的时机！至此，我们的程序已经能够让 Karel 从起点走到终点，并且适用于所有的地图。</p>

<h2 id="函数调用">函数调用</h2>

<p>接下来，我们进一步解决 Karel 如何放置 Beeper 的问题。</p>

<p>有点编程经验的人，可能会想到设置一个 FLAG 标记，来记录间隔放置的状态。但这样不符合题目的要求，因为要求只能使用 Karal 编程语言，所以不存在变量的概念。</p>

<p>仔细看一下 Karel 提供的构件块，目前只能使用过程的方式来确定 Karel 跳过一个格子放置一个 Beeper 的事情，即</p>

<ul>
  <li>走一步</li>
  <li>再走一步</li>
  <li>放置一个 Beeper</li>
</ul>

<p>把这三个动作当成一个整体来考虑，然后通过循环控制结构，直到顶部结束。大概的过程如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="o">(</span><span class="n">frontIsClear</span><span class="o">())</span> <span class="o">{</span>
  <span class="n">move</span><span class="o">();</span>
  <span class="n">move</span><span class="o">();</span>
  <span class="n">putBeeper</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>这个时候，我们应该思考函数调用这件事。</p>

<blockquote>
  <p>Q: 函数可以随便调用吗？如果不是，调用函数的条件是什么呢？</p>
</blockquote>

<p>为了回答这个问题，依次来分析每个函数调用的前置后置条件。</p>

<ul>
  <li>
    <p>走第一步调用 <code class="language-plaintext highlighter-rouge">move</code> 函数：前置条件有循环控制条件来保证，而后置条件可能出现撞墙的情况，所以我们还需要利用之前写好的 <code class="language-plaintext highlighter-rouge">moveUp</code> 函数重写上述过程：</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="o">(</span><span class="n">frontIsClear</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// pre-con</span>
    <span class="n">move</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">frontIsClear</span><span class="o">())</span> <span class="o">{</span>  <span class="c1">// post-con</span>
        <span class="n">move</span><span class="o">();</span> <span class="c1">// 无遮挡情况</span>
        <span class="n">putBeeper</span><span class="o">();</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">moveUp</span><span class="o">();</span> <span class="c1">// 有遮挡情况</span>
        <span class="n">putBeeper</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>无遮挡情况走第二步同样调用 <code class="language-plaintext highlighter-rouge">move</code> 函数：前置条件是无遮挡情况的，移动会很顺利，紧接着就应该放置一个 Beeper。但是，后置条件同样可能会出现遮挡的情况，所以要追加一个处理过程，让 Karel 恢复自由状态：</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="o">(</span><span class="n">frontIsClear</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">move</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">frontIsClear</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">move</span><span class="o">();</span>
        <span class="n">putBeeper</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">frontIsBlocked</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// 结束后有遮挡的情况，恢复Karel自由身</span>
        <span class="n">moveUp</span><span class="o">();</span>
        <span class="n">move</span><span class="o">();</span>
        <span class="n">putBeeper</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">moveUp</span><span class="o">();</span>
        <span class="n">putBeeper</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
  <li>
    <p>有遮挡情况走第二步调用的是 <code class="language-plaintext highlighter-rouge">moveUp</code> 函数：前置条件是有遮挡情况的，可能出现到顶的情况，也就是说 <code class="language-plaintext highlighter-rouge">moveUp</code> 调用会失败。所以是否向上或者放置 Beeper，我们需要再加一个判断：</p>

    <div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">while</span> <span class="o">(</span><span class="n">frontIsClear</span><span class="o">())</span> <span class="o">{</span>
    <span class="n">move</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">frontIsClear</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">move</span><span class="o">();</span>
        <span class="n">putBeeper</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">frontIsBlocked</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">moveUp</span><span class="o">();</span>
        <span class="k">if</span><span class="o">(</span><span class="n">frontIsClear</span><span class="o">()){</span> <span class="c1">// moveUp失败的情况</span>
            <span class="n">move</span><span class="o">();</span>
            <span class="n">putBeeper</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">moveUp</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">frontIsClear</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// moveUp失败的情况</span>
        <span class="n">putBeeper</span><span class="o">();</span>
        <span class="o">}</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div>    </div>
  </li>
</ul>

<p>至此我们完成了整个过程的调用分析，对每个函数的前置后置条件加以区分和约束，使程序最终达到稳定。</p>

<p>回答前面的问题：</p>

<blockquote>
  <p>Q: 函数可以随便调用吗？如果不是，调用函数的条件是什么呢？</p>

  <p>A: 函数是对过程的一个抽象，每次调用都必须检查前置条件和后置条件。</p>
</blockquote>

<p>最后，我们将整个过程放置到 <code class="language-plaintext highlighter-rouge">fixGeneralCase</code> 函数中，对于只有一列的情况，我们做一个 <code class="language-plaintext highlighter-rouge">fixOneColumnCase</code> 函数单独处理就好。</p>

<h2 id="总结">总结</h2>

<p><img src="/assets/img/2021/CheckerboardKarel.gif" alt="CheckerboardKarel" /></p>

<p>完整的代码如下：</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * File: CheckerboardKarel.java
 * ----------------------------
 * When you finish writing it, the CheckerboardKarel class should draw
 * a checkerboard using beepers, as described in Assignment 1.  You
 * should make sure that your program works for all of the sample
 * worlds supplied in the starter folder.
 */</span>

<span class="kn">import</span> <span class="nn">stanford.karel.*</span><span class="o">;</span>

<span class="kd">public</span> <span class="kd">class</span> <span class="nc">CheckerboardKarel</span> <span class="kd">extends</span> <span class="nc">SuperKarel</span> <span class="o">{</span>
  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">run</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">putBeeper</span><span class="o">();</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">frontIsBlocked</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">fixOneColumnCase</span><span class="o">();</span> <span class="c1">// Special case</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="n">fixGeneralCase</span><span class="o">();</span> <span class="c1">// General case</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">// pre-condition: front is blocked</span>
  <span class="c1">// post-condition: front is blocked</span>
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">fixOneColumnCase</span><span class="o">()</span> <span class="o">{</span>
    <span class="n">turnLeft</span><span class="o">();</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">frontIsClear</span><span class="o">())</span> <span class="o">{</span>
      <span class="n">move</span><span class="o">();</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">frontIsClear</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">move</span><span class="o">();</span>
        <span class="n">putBeeper</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">// pre-condition: front is clear</span>
  <span class="c1">// post-condition: front is blocked</span>
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">fixGeneralCase</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">frontIsClear</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// General case</span>
      <span class="c1">// pre-condition: front is clear</span>
      <span class="n">move</span><span class="o">();</span>
      <span class="c1">// post-condition: front is clear/blocked</span>

      <span class="c1">// So, you need to deal with two conditions.</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">frontIsClear</span><span class="o">())</span> <span class="o">{</span>
        <span class="c1">// condition 1: front is clear</span>
        <span class="n">move</span><span class="o">();</span>
        <span class="n">putBeeper</span><span class="o">();</span>
        <span class="c1">// post-condition: front is clear/blocked</span>

        <span class="c1">// Again, you need to double check the blocked condition.</span>
        <span class="c1">// pre-condition: front is blocked</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">frontIsBlocked</span><span class="o">())</span> <span class="o">{</span>
          <span class="n">moveUp</span><span class="o">();</span>
          <span class="k">if</span> <span class="o">(</span><span class="n">frontIsClear</span><span class="o">())</span> <span class="o">{</span> <span class="c1">// just in case moveUp() is failure</span>
            <span class="n">move</span><span class="o">();</span>
            <span class="n">putBeeper</span><span class="o">();</span>
          <span class="o">}</span>
        <span class="o">}</span>
        <span class="cm">/* post-condition: front is clear */</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="c1">// condition 2: front is blocked</span>
        <span class="n">moveUp</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">frontIsClear</span><span class="o">())</span> <span class="c1">// just in case moveUp() is failure</span>
          <span class="n">putBeeper</span><span class="o">();</span>
        <span class="cm">/* post-condition: front is clear */</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">// pre-condition: front is blocked</span>
  <span class="c1">// post-condition: move to the next row and change direction</span>
  <span class="kd">private</span> <span class="kt">void</span> <span class="nf">moveUp</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">facingEast</span><span class="o">())</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">leftIsClear</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">turnLeft</span><span class="o">();</span>
        <span class="n">move</span><span class="o">();</span>
        <span class="n">turnLeft</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">rightIsClear</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">turnRight</span><span class="o">();</span>
        <span class="n">move</span><span class="o">();</span>
        <span class="n">turnRight</span><span class="o">();</span>
      <span class="o">}</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name>薛浩</name><email>xuehao0618@outlook.com</email></author><category term="CS1" /><summary type="html"><![CDATA[最近整理了斯坦福 CS106A 的 Assignment 1，走进了一个叫做 Karel 的世界。]]></summary></entry><entry><title type="html">如何使用 Roberts.CS1.C 库</title><link href="http://localhost:8000/c/2019/12/22/how-to-use-roberts.cs1.c.html" rel="alternate" type="text/html" title="如何使用 Roberts.CS1.C 库" /><published>2019-12-22T00:00:00+08:00</published><updated>2019-12-22T00:00:00+08:00</updated><id>http://localhost:8000/c/2019/12/22/how-to-use-roberts.cs1.c</id><content type="html" xml:base="http://localhost:8000/c/2019/12/22/how-to-use-roberts.cs1.c.html"><![CDATA[<p>《C 语言的科学和艺术》与《C 程序设计的抽象思维》两本书用到的库。</p>

<p>Library source code for the Eric Roberts texts, <em>The Art and Science of C: A Library-Based Approach</em> and <em>Programming Abstractions in C: A Second Course in Computer Science</em>.</p>

<h2 id="如何编译库文件">如何编译库文件？</h2>

<p>Follow these steps to build a personal root system, which don’t need system permission, and generate a static library called <code class="language-plaintext highlighter-rouge">libcs.a</code> for the upper two books.</p>

<p>按如下步骤，创建一个个人 <code class="language-plaintext highlighter-rouge">root</code> 系统（避免系统权限）以及两本书中用到的 <code class="language-plaintext highlighter-rouge">libcs.a</code> 静态库。</p>

<p>Download this repo to your folder.</p>

<p>下载该仓库到个人电脑。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>git clone https://github.com/xuehao/Roberts.CS1.C.git
</code></pre></div></div>

<p>Switch to the folder <code class="language-plaintext highlighter-rouge">cslib</code>. Use <code class="language-plaintext highlighter-rouge">make</code> to build the library.</p>

<p>进入 <code class="language-plaintext highlighter-rouge">cslib</code> 文件夹。执行 <code class="language-plaintext highlighter-rouge">make</code> 命令，生成库文件。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd </span>Roberts.CS1.C <span class="o">&amp;&amp;</span> <span class="nb">cd </span>cslib
<span class="nv">$ </span>make
</code></pre></div></div>

<p>If succeed, you’ll find a folder called <code class="language-plaintext highlighter-rouge">root</code>. Copy the <code class="language-plaintext highlighter-rouge">root</code> folder to your home directory.</p>

<p>如果成功，此时会生成一个 <code class="language-plaintext highlighter-rouge">root</code> 文件夹。复制 <code class="language-plaintext highlighter-rouge">root</code> 文件到个人目录。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mv </span>root ~
</code></pre></div></div>

<h2 id="如何链接库文件">如何链接库文件？</h2>

<p>Package all the options for the compiler and the linker used while building the C program into the general <code class="language-plaintext highlighter-rouge">Makefile</code>.</p>

<p>把构建C程序用到的编译器选项和链接器选项打包放进通用 <code class="language-plaintext highlighter-rouge">Makefile</code> 中。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CC = gcc
CFLAGS = -I${HOME}/root/include/cs -g -Wall -std=gnu11 -O3
LDLIBS = -L${HOME}/root/lib/ -lcs -lm
</code></pre></div></div>

<p>Use the general <code class="language-plaintext highlighter-rouge">Makefile</code> in the <code class="language-plaintext highlighter-rouge">test-cslib</code> folder to build the <code class="language-plaintext highlighter-rouge">house.c</code> program and to see how to connect the library.</p>

<p>使用 <code class="language-plaintext highlighter-rouge">test-cslib</code> 中的通用 <code class="language-plaintext highlighter-rouge">Makefile</code> 文件编译 <code class="language-plaintext highlighter-rouge">house.c</code> 测试程序，看看如何链接库文件。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">cd</span> .. <span class="o">&amp;&amp;</span> <span class="nb">cd </span>test-cslib
<span class="nv">$ </span>make house
<span class="nv">$ </span>./house
</code></pre></div></div>

<p>This will produce a data file called <code class="language-plaintext highlighter-rouge">graphics.ps</code>.</p>

<p>此时会生成名为 <code class="language-plaintext highlighter-rouge">graphics.ps</code> 的数据文件。</p>]]></content><author><name>薛浩</name><email>xuehao0618@outlook.com</email></author><category term="C" /><summary type="html"><![CDATA[《C 语言的科学和艺术》与《C 程序设计的抽象思维》两本书用到的库。]]></summary></entry><entry><title type="html">在 Linux 环境下学习 C 语言</title><link href="http://localhost:8000/c/2019/12/21/learning-c-on-linux.html" rel="alternate" type="text/html" title="在 Linux 环境下学习 C 语言" /><published>2019-12-21T00:00:00+08:00</published><updated>2019-12-21T00:00:00+08:00</updated><id>http://localhost:8000/c/2019/12/21/learning-c-on-linux</id><content type="html" xml:base="http://localhost:8000/c/2019/12/21/learning-c-on-linux.html"><![CDATA[<p>本文介绍如何在 Linux 平台，以一种“透明”的方式学习 C 语言。</p>

<h2 id="创建个人-root-系统">创建个人 root 系统</h2>

<p>所谓“个人 root”系统，其实就是避免把软件安装到系统路径。这样我们可以方便的查看 root 目录下的文件，审查所安装软件的具体行为，而不必到系统目录中查找。创建个人 root 系统还可以避免使用系统 root 权限。</p>

<p>创建 root 系统目录：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mkdir</span> ~/root <span class="c"># 用于保存非系统程序库</span>
</code></pre></div></div>

<p>将个人 root 系统目录添加到系统路径：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">mkdir</span> ~/root <span class="c"># 用于保存非系统程序库</span>
</code></pre></div></div>

<p>其实，这样的个人路径，在类似 Ubuntu 的系统中已经默认存在了，即个人文件夹下的 <code class="language-plaintext highlighter-rouge">.local</code> 目录。如果你愿意，完全可以使用该目录，而且不需要去修改系统路径。</p>

<h2 id="从源码编译程序库">从源码编译程序库</h2>

<p>学习 C 语言完全可以像学习 Python 那样，直接使用现成的库。在 C 语言几十年的发展过程中，除了标准库的更新外，还产生了无数质量上乘的第三方库。利用这些库，我们可以更愉快的编程了。</p>

<p>下面会以 <a href="https://www.gnu.org/software/gsl/" target="_blank">GSL</a> 库为例，介绍类似第三方库的安装和使用方法，为后续学习其他的库奠定基础。</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>wget http://mirrors.ustc.edu.cn/gnu/gsl/gsl-2.6.tar.gz
<span class="nv">$ </span><span class="nb">tar </span>xvzf gsl-2.6.tar.gz
<span class="nv">$ </span><span class="nb">cd </span>gsl-2.6
<span class="nv">$ </span>./configure <span class="nt">--prefix</span><span class="o">=</span><span class="nv">$HOME</span>/root <span class="c"># 使用 prefix 参数指定安装目录</span>
<span class="nv">$ </span>make <span class="o">&amp;&amp;</span> make <span class="nb">install</span>
</code></pre></div></div>

<p>该程序库将被添加到个人 root 系统，可以去目录中查看具体安装了哪些东西。</p>

<h2 id="构建包含库的-c-程序">构建包含库的 C 程序</h2>

<p>编写测试程序：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 文件名：gsl_erf.c</span>
<span class="cp">#include</span> <span class="cpf">&lt;math.h&gt;</span><span class="c1">        // erf, sqrt 等</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="c1">       // printf 等</span><span class="cp">
#include</span> <span class="cpf">&lt;gsl/gsl_cdf.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">bottom_tail</span> <span class="o">=</span> <span class="n">gsl_cdf_gaussian_P</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">.</span><span class="mi">96</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Area between [-1.96, 1.96]: %g</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">bottom_tail</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>编写 <code class="language-plaintext highlighter-rouge">Makefile</code> 文件，通过 <code class="language-plaintext highlighter-rouge">-I</code> 指定库的头文件搜索路径；通过 <code class="language-plaintext highlighter-rouge">-L</code> 指定库的搜索路径：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CFLAGS=-I${HOME}/root/include -g -Wall -std=gnu11 -O3
LDLIBS=-L${HOME}/root/lib -lgsl -lgslcblas -lm
</code></pre></div></div>

<p>或者使用 GSL 自带的配置信息，该命令会自动计算出相关的路径：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CFLAGS=`gsl-config --cflags` -g -Wall -std=gnu11 -O3
LDLIBS=`gsl-config --libs`
</code></pre></div></div>

<p>编译测试程序：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>make gsl_erf
</code></pre></div></div>

<p>运行测试程序：</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span><span class="nb">export </span><span class="nv">LD_LIBRARY_PATH</span><span class="o">=</span><span class="nv">$HOME</span>/root/lib:<span class="nv">$LD_LIBRARY_PATH</span> <span class="c"># 指定库路径</span>
<span class="nv">$ </span>./gsl_erf
Area between <span class="o">[</span><span class="nt">-1</span>.96, 1.96]: 0.950004
</code></pre></div></div>

<p>对于运行时需要连接共享库的程序，和编译过程一样，同样需要指定库的路径，可以通过修改 <code class="language-plaintext highlighter-rouge">LD_LIBRARY_PATH</code> 变量实现。</p>

<h2 id="关于-gcc-和-makefile">关于 GCC 和 Makefile</h2>

<p><code class="language-plaintext highlighter-rouge">Makefile</code> 编译过程的套路一般为：</p>

<ul>
  <li>设置编译器选项的变量：<code class="language-plaintext highlighter-rouge">CFLAGS</code> 为我们提供了编译器的一些选项</li>
  <li>设置连接器选项的变量：<code class="language-plaintext highlighter-rouge">LDLIBS</code> 为我们提供了连接器的一些选项。</li>
  <li>使用 <code class="language-plaintext highlighter-rouge">make</code> 等工具将变量转换成真正的编译和连接的命令</li>
</ul>

<p>常用编译器选项：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">选项</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">-g</td>
      <td style="text-align: center">加入调试符号</td>
    </tr>
    <tr>
      <td style="text-align: center">-Wall</td>
      <td style="text-align: center">添加编译器警告</td>
    </tr>
    <tr>
      <td style="text-align: center">-std=gun11</td>
      <td style="text-align: center">编译器版本为 C11</td>
    </tr>
    <tr>
      <td style="text-align: center">-O3</td>
      <td style="text-align: center">优化等级为 3</td>
    </tr>
    <tr>
      <td style="text-align: center">-o</td>
      <td style="text-align: center">指定输出的文件名，默认文件名为 <code class="language-plaintext highlighter-rouge">a.out</code></td>
    </tr>
  </tbody>
</table>

<p>常用连接器选项：</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">选项</th>
      <th style="text-align: center">说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">-I(大写的 i)</td>
      <td style="text-align: center">添加头文件搜索路径</td>
    </tr>
    <tr>
      <td style="text-align: center">-L</td>
      <td style="text-align: center">添加库文件搜索路径</td>
    </tr>
    <tr>
      <td style="text-align: center">-l(小写的 L)</td>
      <td style="text-align: center">指定需要连接的库：<code class="language-plaintext highlighter-rouge">-lgsl</code> 自动连接名为 <code class="language-plaintext highlighter-rouge">libgsl.a</code> 库</td>
    </tr>
  </tbody>
</table>]]></content><author><name>薛浩</name><email>xuehao0618@outlook.com</email></author><category term="C" /><summary type="html"><![CDATA[本文介绍如何在 Linux 平台，以一种“透明”的方式学习 C 语言。]]></summary></entry></feed>